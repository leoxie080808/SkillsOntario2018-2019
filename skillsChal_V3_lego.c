#pragma config(UART_Usage, UART1, uartUserControl, baudRate115200, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    centerOne,      sensorNone)
#pragma config(Sensor, in2,    centerTwo,      sensorReflection)
#pragma config(Sensor, in3,    centerThree,    sensorReflection)
#pragma config(Sensor, in7,    clawPos,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  elevatorTop,    sensorTouch)
#pragma config(Sensor, dgtl2,  elevatorDown,   sensorTouch)
#pragma config(Sensor, dgtl3,  startTouch,     sensorTouch)
#pragma config(Sensor, dgtl5,  frontStrafeWheel, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  leftUltra,      sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  strafeWheel,    sensorQuadEncoder)
#pragma config(Sensor, dgtl11, rightUltra,     sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           liftOne,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           liftTwo,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           center,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           centerTwo,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           leftOne,       tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port7,           leftTwo,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           rightOne,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port9,           rightTwo,      tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

void followLinePickUpBlock();
void dropOffBlock();
void followLine();

float angleOffset = 0;
#define LIGHT_RIGHT		0
#define LIGHT_CENTER	1
#define LIGHT_LEFT		2
#define WHITE_TH			200
#define BLACK_TH			1500
#include "./uart_gyro.c"
#include "./pid/pid.c";
#include "./navigationctrl.c"
#include "./hdrive_ctrl.c"
#include "./lift_claw_ctrl.c"
#include "./layout6.c"
#include "./layout5.c"
#include "./layout4.c"
#include "./layout3.c"
#include "./layout2.c"
#include "./layout1.c"
#define MAIN_LOOP_PERIOD			10


task LCDDisplayTask()
{
	string strGyro;
	string strComCnt;
	while(true)
	{
		clearLCDLine(0);											// Clear line 1 (0) of the LCD
		clearLCDLine(1);											// Clear line 2 (1) of the LCD

		//Display the Primary Robot battery voltage
		displayLCDString(0, 0, "Gyro =");
		sprintf(strGyro, "%1.2f%c", gyroAngle,'D'); //Build the value to be displayed
		displayNextLCDString(strGyro);

		//Display the Backup battery voltage
		displayLCDString(1, 0, "ComCnt: ");
		sprintf(strComCnt, "%4d", comCnt);	//Build the value to be displayed
		displayNextLCDString(strComCnt);
		wait10Msec(100);
	}
}

void followLinePickUpBlock()
{
	clawOpen();
  followLine();	// will stop both light sensor at white
  //forward a little bit
  driveStraight(0.00, robotHeading, 0.1, 0.005, 0);
  clawHold();
  wait10Msec(50);
}

void dropOffBlock()
{
	// lower the claw
		liftCtrl(-50);
		clawOpen();
		wait10Msec(50);
		// lift the claw
		liftCtrl(60);
		clawClose();
		wait10Msec(50);
}

void followLine()
{
	while(!((SensorValue[LIGHT_CENTER] < WHITE_TH) && (SensorValue[LIGHT_LEFT] < WHITE_TH) && (SensorValue[LIGHT_RIGHT] < WHITE_TH)))
	{
		// CENTER sensor sees dark:
		if(SensorValue[LIGHT_CENTER] > BLACK_TH)
		{
			// go straight
			driveWheels(25,25);
		}
		else if(SensorValue[LIGHT_RIGHT] > BLACK_TH)
		{
			// counter-steer right:
			driveWheels(32,10);
		}

		// LEFT sensor sees dark:
		else if(SensorValue[LIGHT_LEFT] > BLACK_TH)
		{
			// counter-steer left:
			driveWheels(10,32);
		}
		else
		{
			// go straight
			driveWheels(30,30);
		}

	}
	driveWheels(0,0);
}


task main()
{
	float robotHeading = 0;
	initUart();
	startTask(LCDDisplayTask);

	/*
	SensorType[in4] = sensorNone;
	wait1Msec(2000);
	//Reconfigure Analog Port 1 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in4] = sensorGyro;
	wait1Msec(5000);
	//Adjust SensorScale to correct the scaling for your gyro
	SensorScale[in4] = GYRO_SCALE;
	//Adjust SensorFullCount to set the "rollover" point. 3600 sets the rollover point to +/-3600
	SensorFullCount[in4] = GYRO_RANGE;
	*/
	wait1Msec(2000);
	SensorValue[frontStrafeWheel] = 0;
	SensorValue[strafeWheel] = 0;
	SensorValue[I2C_2]  = 0;
	SensorValue[I2C_3]  = 0;


	wait1Msec(100);
	// must start this task and keep this task live
	startTask(speedEstimateTask);
	wait10Msec(100);
	/*
	liftCtrl(-60);// will lift up claw
	wait10Msec(100);
	// start the claw control task and keep this task live
	// you only need change the set target and Kp value
	clawTarget = CLAW_RESET;
	startTask(clawCtrlTask);
	liftCtrl(60);// will lift up claw
	*/
	wait10Msec(100);
	writeDebugStreamLine("start testing....");
	while(true)
	{

	//	strafeWheels(vexRT[Ch1],vexRT[Ch1]);

	//	driveWheels(vexRT[ch3] + vexRt[Ch4],vexRT[ch3] - vexRt[Ch4]);


		if (vexRT[Btn8L] == 1)
		{
			//	driveWheels(-30,30);
		//		strafeWheels(50,50);
			//driveStraight(1.5, 0, 0.25,0.006,0.02);
			//wait10Msec(300);
			//driveStraight(1.5, 0, -0.25,0.006,0.02);
			//	strafeStraight(1.0,robotHeading,50,0.5);
			//	wait10Msec(300);
			//	strafeStraight(1.0,robotHeading,-50,0.5);
		//		turnGyro(3600, 0.4, 0.1,100, 20,40,0);
			/*
			turnGyro(-3600, 0.4, 0.1,100, 20,20,0);
			wait10Msec(100);
			turnGyro(0, 0.4, 0.1,100, 20,20,0);
			wait10Msec(100);
			turnGyro(-3600, 0.4, 0.1,100, 20,20,0);
			wait10Msec(100);
			turnGyro(0, 0.4, 0.1,100, 20,20,0);
			*/
	//	 	strafeStraight(1.0,0,-100,0.8);
	//		strafeToBlack(-50,0,1, LIGHT_CENTER);
	//		followLineTask();
			//strafeToDis(70,0, 3,30);
		//	strafeToDis(-100,0, 3,30);
			///////////////////////////////////////////////////////////////
/*
			robotHeading = 0;
			// move back 36cm
			driveStraight(0.36, robotHeading, -0.2,0.007,0.03);		// dis, angle, speed, kp, momentum

			liftCtrl(-60);// will lift up claw
			wait10Msec(100);
			// start the claw control task and keep this task live
			// you only need change the set target and Kp value
			clawTarget = CLAW_RESET;
			startTask(clawCtrlTask);
			liftCtrl(60);// will lift up claw
			wait10Msec(100);
			// h drive to left 0.2
			strafeStraight(0.3,robotHeading,-50,1.0);

			//followLinePickUpBlock();
		  //move back 1.7
		  robotHeading = 0;
		  driveStraight(1.74, robotHeading, -0.3,0.007,0.03);		// dis, angle, speed, kp, momentum
		  wait10Msec(50);
		  sonarReading = SensorValue[leftUltra];
		  wait10Msec(50);
		  sonarReading = (sonarReading + SensorValue[leftUltra]) /200;
		  float dis = 0.45 + sonarReading - 0.3;
		  writeDebugStreamLine("set dis = %f", dis);
		  strafeStraight(dis,robotHeading,60,1.0);
		  wait10Msec(50);
			robotHeading = -1800;
			turnGyro(robotHeading, 0.4, 0.1,100, 10,40,0);

			dropOffBlock();
		*/
			//////////////////////////////////////////////////////////////


		}
		else
		{
	//		driveWheels(0,0);
	//		strafeWheels(0,0);
		}
////////////////////////////////////////////////////////////////
		// to make sure the robot working, please
		//please use these buttons to test robot before competion start
		if(vexRT[Btn7U] == 1)
		{
			liftCtrl(60);
			clawOpen();
		}
		else
		{

		}
		if(vexRT[Btn7D] == 1)
		{
			clawHold();
		}

		if (vexRT[Btn7L] == 1)
		{



			liftCtrl(-50);

		}

		if (vexRT[Btn7R] == 1)
		{

			driveStraight(0.45, robotHeading, 0.25,0.007,0.03);
			strafeStraight(0.4, robotHeading, -50, 1.0);

		}

///////////////////////////////////////////////////////////////////////////
		if (vexRT[Btn8U] == 1)
		{
				//layout6();
		//layout5();
		//layout4();
		//layout3();
			layout2();
		//	layout1();
		}


		if (SensorValue[dgtl3] == 1){
			wait1Msec(3000);
			layout1();



		}


		wait1Msec(MAIN_LOOP_PERIOD);
	}


}
